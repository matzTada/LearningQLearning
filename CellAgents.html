<html>
<head>
  <meta charset="UTF-8">

  <link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/smoothness/jquery-ui.css">
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">

  <script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
	<script type="text/javascript" src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"></script>

  <script language="javascript" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.0.0/p5.min.js"></script>

  <style>
    body {padding: 0; margin: 0;} /* to avoid to show scroll bars*/
    canvas {
      height: 100vh;
		  width: 100%;
		  position: relative;
		  left: 0;
		  top: 0;
      /* display: block; */
      }  /* to avoid to show scroll bars*/
  </style>
</head>
<body>
  <!-- <div class="container-fluid">
    <div class="col"> -->
      <div id="p5canvas"></div>
    <!-- </div>
  </div> -->
</body>

<script language="javascript" type="text/javascript">

var loopflag = true;

function mouseClicked(){
  if(loopflag == true){
    noLoop();
  }else{
    loop();
  }
  loopflag = !loopflag;
}

var environment = [];
var env_width = 8;
var env_height = 8;
var cell_size = 0;
var goals = [];

var agents = [];
var q_table = [];

function setup() {
  // initialize environment
  for (var h = 0; h < env_height; h++) environment.push(new Array(env_width).fill(-1))
  // set obstacles
  for (var i = 0; i < env_width*env_height/10; i++) environment[floor(random(0,env_height))][floor(random(0,env_width))] = -100;
  // set goals
  for (var i = 0; i < 1; i++) {
    var tmp = {
      x : floor(random(0,env_width)),
      y : floor(random(0,env_height)),
    }
    goals.push(tmp);
    environment[tmp.y][tmp.x] = 100;
  }

  // set agents
  for (var i = 0; i < 5; i++) {
    agents.push({
      x : floor(random(0,env_width)),
      y : floor(random(0,env_height)),
    });
  }

  // initialize q_table
  for (var i = 0; i < env_height*env_width; i++) q_table.push(new Array(4).fill(0))
  // --- detail of q_table ---
  // 2 dimensional array. line direction for each state. columns direction for each action of agent
  // (state number = index number) = (line)*env_width+(colums)
  // i.e. imagine env_height = 4, env_width = 4
  //   (x,y) = (0,3) => state number is 3
  //   (x,y) = (2,1) => state number is 2 * 1 + 4 = 6

  // --- p5 js initialize start ---
  var can = createCanvas($("#p5canvas").width(), windowHeight);
  can.parent("p5canvas");
  // --- p5 js initialize end ---
  colorMode(HSB, 100);
  frameRate(32);

  // for visulize
  cell_size = min(width/env_width, height/env_height);
}

function draw() {
  background(0);

  for (var h = 0; h < env_height; h++) {
    for (var w = 0; w < env_width; w++) {
      stroke(0);
      if(environment[h][w] == -100) {
        fill(0, 50, 100)
      }else if(environment[h][w] == 100) {
        fill(33, 50, 100)
      }else{
        fill(66, 50, 100)
      }
      rect(cell_size*w, cell_size*h, cell_size, cell_size)

      noStroke();
      fill(255);
      var circlesize = cell_size/4;
      var state_q_value_max = max(q_table[getstate(h, w)]);
      (q_table[getstate(h, w)][0] >= state_q_value_max) ? fill(255) : noFill();
      triangle_directed(cell_size*(w+0.5), cell_size*h, circlesize, HALF_PI);
      (q_table[getstate(h, w)][1] >= state_q_value_max) ? fill(255) : noFill();
      triangle_directed(cell_size*(w+0.5), cell_size*(h+1), circlesize, -HALF_PI);
      (q_table[getstate(h, w)][2] >= state_q_value_max) ? fill(255) : noFill();
      triangle_directed(cell_size*w, cell_size*(h+0.5), circlesize, 0);
      (q_table[getstate(h, w)][3] >= state_q_value_max) ? fill(255) : noFill();
      triangle_directed(cell_size*(w+1), cell_size*(h+0.5), circlesize, PI);

      noStroke();
      fill(0);
      textSize(height/q_table.length/2)
      textAlign(CENTER, TOP)
      text(nfc(q_table[getstate(h, w)][0], 1), cell_size*(w+0.5), cell_size*h);
      textAlign(CENTER, BOTTOM)
      text(nfc(q_table[getstate(h, w)][1], 1), cell_size*(w+0.5), cell_size*(h+1));
      textAlign(LEFT, CENTER)
      text(nfc(q_table[getstate(h, w)][2], 1), cell_size*w, cell_size*(h+0.5));
      textAlign(RIGHT, CENTER)
      text(nfc(q_table[getstate(h, w)][3], 1), cell_size*(w+1), cell_size*(h+0.5));

      noStroke();
      fill(0);
      textSize(height/q_table.length/2)
      textAlign(CENTER, CENTER);
      text(environment[h][w], cell_size*(w+0.5), cell_size*(h+0.5));

    }
  }

  // line visualize
  for (var h = 0; h < env_height; h++) {
    for (var w = 0; w < env_width; w++) {
      stroke(255);
      noFill();
      var circlesize = cell_size/4;
      var state_q_value_max = max(q_table[getstate(h, w)]);
      (q_table[getstate(h, w)][0] >= state_q_value_max) ? stroke(255) : noStroke();
      line(cell_size*(w+0.5), cell_size*(h-0.5), cell_size*(w+0.5), cell_size*(h+0.5));
      (q_table[getstate(h, w)][1] >= state_q_value_max) ? stroke(255) : noStroke();
      line(cell_size*(w+0.5), cell_size*(h+0.5), cell_size*(w+0.5), cell_size*(h+1.5));
      (q_table[getstate(h, w)][2] >= state_q_value_max) ? stroke(255) : noStroke();
      line(cell_size*(w-0.5), cell_size*(h+0.5), cell_size*(w+0.5), cell_size*(h+0.5));
      (q_table[getstate(h, w)][3] >= state_q_value_max) ? stroke(255) : noStroke();
      line(cell_size*(w+0.5), cell_size*(h+0.5), cell_size*(w+1.5), cell_size*(h+0.5));
    }
  }


  // visualize agents
  stroke(255);
  fill(15, 50, 100);
  for (var i = 0; i < agents.length; i++) {
    ellipse(cell_size*(agents[i].x+0.5), cell_size*(agents[i].y+0.5), cell_size/2, cell_size/2)
  }

  // visualize q_table
  for (var h = 0; h < q_table.length; h++) {
    for (var w = 0; w < q_table[0].length; w++) {
      stroke(255);
      fill(255);
      textAlign(LEFT, TOP)
      textSize(height/q_table.length/4)
      text(nfc(q_table[h][w], 1), cell_size*env_width+(width-cell_size*env_width)*w/q_table[0].length, height*h/q_table.length)
    }
  }

  // --- logic ---
  for (var i = 0; i < agents.length; i++) {
    var nextpos = {x: agents[i].x, y: agents[i].y};
    var nextaction = floor(random(0,4));
    var movementflag = true;
    switch (nextaction) {
      case 0: (nextpos.y!=0)?nextpos.y -= 1:movementflag=false; break;
      case 1: (nextpos.y!=env_height-1)?nextpos.y += 1:movementflag=false; break;
      case 2: (nextpos.x!=0)?nextpos.x -= 1:movementflag=false; break;
      case 3: (nextpos.x!=env_width-1)?nextpos.x += 1:movementflag=false; break;
    }
    var currentstate = getstate(agents[i].y, agents[i].x);
    var nextstate = getstate(nextpos.y, nextpos.x);

    var alpha = 0.7;
    var gamma = 0.9; // time discount
    var q_value = alpha*(environment[agents[i].y][agents[i].x]+gamma*max(q_table[nextstate]))
      +(1-alpha)*environment[agents[i].y][agents[i].x];
    if(movementflag == false) q_value = -100;
    q_table[currentstate][nextaction] = q_value;

    // console.log("agents[i]", agents[i])
    // console.log("currentstate", currentstate)
    // console.log("nextaction", nextaction)
    // console.log("nextpos", nextpos)
    // console.log("nextstate", nextstate)
    // console.log("q_value", q_value)

    agents[i].x = nextpos.x;
    agents[i].y = nextpos.y;
  }

  // visualize simulation environment info

  noStroke();
  fill(255);
  textAlign(RIGHT, BOTTOM)
  textSize(height/40);
  text("frameRate():" + nfc(frameRate(),1), width, height);
}

function getstate(_y, _x){
  return _y*env_width+_x;
}

function triangle_directed(_x, _y, _height, _angle){
  push();
  translate(_x, _y);
  rotate(-HALF_PI/2+_angle);
  triangle(0, 0, _height*sqrt(2), 0, 0, _height*sqrt(2));
  pop();
}

</script>

</html>
